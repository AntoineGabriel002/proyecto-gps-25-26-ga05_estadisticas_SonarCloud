/*
 * Microservicio de Estadisticas - GA04
 *
 * Especificacion OpenAPI del microservicio de \"Estadisticas\" dentro del proyecto \"Undersounds\" de GPS/ASEE.  El codigo del proyecto esta disponible en el [repositorio de GitHub](https://github.com/UniExtremadura/proyecto-gps-25-26-ga05).
 *
 * API version: 0.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gocql/gocql"
)

type UsuariosAPI struct {
	DB *gocql.Session
}

// Get /usuarios/:idUsuario/estadisticas
// Obtener estadisticas de consumo de un usuario
func (api *UsuariosAPI) UsuariosIdUsuarioEstadisticasGet(c *gin.Context) {
	idUsuarioStr := c.Param("idUsuario")
	idUsuario, err := strconv.Atoi(idUsuarioStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "idUsuario inválido"})
		return
	}

	periodo := c.DefaultQuery("periodo", "total")
	fechaFiltro, filtered := getFechaFiltro(periodo)

	var totalEscuchas int32
	var totalComprasAlbumes int32
	var totalComprasMerch int32

	if !filtered {
		if v, err := countTotal(api.DB, `SELECT COUNT(*) FROM escucha WHERE idUsuario = ?`, int32(idUsuario)); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando escuchas: " + err.Error()})
			return
		} else {
			totalEscuchas = v
		}
		if v, err := countTotal(api.DB, `SELECT COUNT(*) FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario)); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando compras de álbumes: " + err.Error()})
			return
		} else {
			totalComprasAlbumes = v
		}
		if v, err := countTotal(api.DB, `SELECT COUNT(*) FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario)); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando compras de merchandising: " + err.Error()})
			return
		} else {
			totalComprasMerch = v
		}
	} else {
		if v, err := countSince(api.DB, `SELECT idCancion, fecha FROM escucha WHERE idUsuario = ?`, int32(idUsuario), fechaFiltro); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando escuchas: " + err.Error()})
			return
		} else {
			totalEscuchas = v
		}
		if v, err := countSince(api.DB, `SELECT idAlbum, fecha FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario), fechaFiltro); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando compras de álbumes: " + err.Error()})
			return
		} else {
			totalComprasAlbumes = v
		}
		if v, err := countSince(api.DB, `SELECT idMerch, fecha FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario), fechaFiltro); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando compras de merchandising: " + err.Error()})
			return
		} else {
			totalComprasMerch = v
		}
	}

	estadisticas := EstadisticasUsuario{
		IdUsuario:           int32(idUsuario),
		TotalEscuchas:       totalEscuchas,
		TotalComprasAlbumes: totalComprasAlbumes,
		TotalComprasMerch:   totalComprasMerch,
	}

	c.JSON(http.StatusOK, estadisticas)
}

// Get /usuarios/:idUsuario/historialCompras
// Obtener historial de compras de un usuario
func (api *UsuariosAPI) UsuariosIdUsuarioHistorialComprasGet(c *gin.Context) {
	idUsuarioStr := c.Param("idUsuario")
	idUsuario, err := strconv.Atoi(idUsuarioStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "idUsuario inválido"})
		return
	}

	historial := HistorialCompras{}

	// --- Compras de álbumes ---
	var historialAlbum []HistorialComprasAlbumes
	iterAlbum := api.DB.Query(`SELECT idAlbum, fecha FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario)).Iter()
	var idAlbum int32
	var fechaAlbum time.Time
	for iterAlbum.Scan(&idAlbum, &fechaAlbum) {
		nombre, urlImagen, err := fetchAlbumContenido(idAlbum)
		if err != nil {
			fmt.Printf("Error fetchAlbumContenido para idAlbum=%d: %v\n", idAlbum, err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"status":  "error",
				"message": fmt.Sprintf("error obteniendo información de álbum: %v", err),
			})
			return
		}

		historialAlbum = append(historialAlbum, HistorialComprasAlbumes{
			IdAlbum:   idAlbum,
			Fecha:     fechaAlbum.Format(time.RFC3339),
			Nombre:    nombre,
			UrlImagen: urlImagen,
		})
	}

	if err := iterAlbum.Close(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	historial.ComprasAlbumes = historialAlbum

	// --- Compras de merchandising ---
	var historialMerch []HistorialComprasMerchandising
	iterMerch := api.DB.Query(`SELECT idMerch, fecha FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario)).Iter()
	var idMerch int32
	var fechaMerch time.Time
	for iterMerch.Scan(&idMerch, &fechaMerch) {
		nombre, urlImagen, err := fetchMerchContenido(idMerch)
		if err != nil {
			fmt.Printf("Error fetchMerchContenido para idMerch=%d: %v\n", idMerch, err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"status":  "error",
				"message": fmt.Sprintf("error obteniendo información de merchandising: %v", err),
			})
			return
		}

		historialMerch = append(historialMerch, HistorialComprasMerchandising{
			IdMerch:   idMerch,
			Fecha:     fechaMerch.Format(time.RFC3339),
			Nombre:    nombre,
			UrlImagen: urlImagen,
		})
	}

	if err := iterMerch.Close(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	historial.ComprasMerchandising = historialMerch

	c.JSON(http.StatusOK, gin.H{
		"status":    "OK",
		"historial": historial,
	})
}

func fetchAlbumContenido(id int32) (string, string, error) {
	resp, err := http.Get(fmt.Sprintf("http://contenido-app:8080/albums/%d", id))
	if err != nil {
		return "", "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("servicio de contenido devolvió código %d", resp.StatusCode)
	}

	// Decodificamos DIRECTAMENTE el Album que devuelve el microservicio
	var album struct {
		Nombre string `json:"nombre"`
		Imagen []byte `json:"imagen"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&album); err != nil {
		return "", "", err
	}

	// Convertimos la imagen a base64
	urlImagen := ""
	if len(album.Imagen) > 0 {
		urlImagen = "data:image/jpeg;base64," + base64.StdEncoding.EncodeToString(album.Imagen)
	}

	return album.Nombre, urlImagen, nil
}

func fetchMerchContenido(id int32) (string, string, error) {
	resp, err := http.Get(fmt.Sprintf("http://contenido-app:8080/merch/%d", id))
	if err != nil {
		return "", "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("servicio de contenido devolvió código %d", resp.StatusCode)
	}

	var data struct {
		Status string `json:"status"`
		Merch  struct {
			Nombre string `json:"nombre"`
			Imagen string `json:"imagen"` // campo en Base64
		} `json:"merch"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", "", err
	}

	// Construir URL data:image/jpeg;base64
	var urlImagen string
	if data.Merch.Imagen != "" {
		urlImagen = fmt.Sprintf("data:image/jpeg;base64,%s", data.Merch.Imagen)
	}

	return data.Merch.Nombre, urlImagen, nil
}

func getFechaFiltro(periodo string) (time.Time, bool) {
	now := time.Now()
	switch periodo {
	case "mes":
		return now.AddDate(0, -1, 0), true
	case "anno":
		return now.AddDate(-1, 0, 0), true
	default:
		return time.Time{}, false
	}
}

func countTotal(db *gocql.Session, query string, args ...interface{}) (int32, error) {
	var count int
	if err := db.Query(query, args...).Scan(&count); err != nil {
		return 0, err
	}
	return int32(count), nil
}

func countSince(db *gocql.Session, query string, argsAndUser ...interface{}) (int32, error) {
	if len(argsAndUser) < 2 {
		return 0, fmt.Errorf("args insuficientes")
	}
	fechaFiltro, ok := argsAndUser[len(argsAndUser)-1].(time.Time)
	if !ok {
		return 0, fmt.Errorf("último argumento debe ser time.Time")
	}
	args := argsAndUser[:len(argsAndUser)-1]

	iter := db.Query(query, args...).Iter()
	var dummy int32
	var fecha time.Time
	var total int32
	for iter.Scan(&dummy, &fecha) {
		if fecha.After(fechaFiltro) {
			total++
		}
	}
	if err := iter.Close(); err != nil {
		return 0, err
	}
	return total, nil
}
